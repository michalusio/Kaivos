#include "..\noiseSimplex.cginc"
#include "..\blockList.cginc"

RWTexture2D<float4> FrameBefore;
RWTexture2D<float4> NewFrame;
int seed;
float Time;

static const int3 eee = int3(1, 0, -1);

float seedNoise(float2 pos)
{
	return snoise(pos + seed);
}

float seedNoise(float3 pos)
{
	return snoise(pos + seed);
}

bool rand(float2 pos)
{
	return seedNoise(Time * 37 + pos) > 0;
}

bool rand(float2 pos, int times)
{
	return rand(pos + times * 223);
}

#pragma kernel GenerateTerrain
[numthreads(16, 16, 1)]
void GenerateTerrain(uint3 id : SV_DispatchThreadID)
{
	uint w, h;
	NewFrame.GetDimensions(w, h);
	float rockGrayNoise = seedNoise(id.xy/50.0);
	float rockBrownNoise = seedNoise(id.xy/float2(200.0, 25.0)+20);
	float4 whatToPlace = float4(0, 0, 0, 0);
	
	if ((int)id.y < h - 32.0)
	{
		if (rockGrayNoise * rockBrownNoise < 0.5)
		{
			whatToPlace = lerp(ROCK1, ROCK2, step(rockGrayNoise, rockBrownNoise));
			if (rockGrayNoise * rockBrownNoise < 0.4)
			{
				float heightPart = (h - id.y)/(float)h;
				
				float ironNoise = max(0, seedNoise(id.xy/ORE_SIZE+40)) * (1-(heightPart-MAPGEN_IRON_H)*(heightPart-MAPGEN_IRON_H));
				float coalNoise = max(0, seedNoise(id.xy/ORE_SIZE+60)) * (1-(heightPart-MAPGEN_COAL_H)*(heightPart-MAPGEN_COAL_H));
				float copperNoise = max(0, seedNoise(id.xy/ORE_SIZE+80)) * (1-(heightPart-MAPGEN_COPPER_H)*(heightPart-MAPGEN_COPPER_H));
				float goldNoise = max(0, 0.8 * seedNoise(id.xy/ORE_SIZE+100)) * (1-(heightPart-MAPGEN_GOLD_H)*(heightPart-MAPGEN_GOLD_H));
				float maxNoise = max(max(max(ironNoise,coalNoise),copperNoise),goldNoise);
				if (maxNoise > 0.7)
				{
					if (ironNoise == maxNoise)
					{
						whatToPlace = IRON;
					}
					else if (coalNoise == maxNoise)
					{
						whatToPlace = COAL;
					}
					else if (copperNoise == maxNoise)
					{
						whatToPlace = COPPER;
					}
					else if (goldNoise == maxNoise)
					{
						whatToPlace = GOLD;
					}
				}
			}
		}
		else if (id.y < h / 2)
		{
			whatToPlace = LAVA;
		}
		else
		{
			whatToPlace = WATER;
		}
	}
	
	float dirtNoise = (seedNoise(float2(id.x / 50.0 + 80, 0.5)) + 1) * 5 + h - 38.0;
	if (abs(id.y - dirtNoise) < 5)
	{
		whatToPlace = DIRT;
	}
	if (abs(id.y - dirtNoise - 5) < 0.5)
	{
		whatToPlace = GRASS;
	}
	if (id.y == 0)
	{
		whatToPlace = BEDROCK;
	}
	
	NewFrame[id.xy] = whatToPlace;
}

#pragma kernel Particles
[numthreads(256, 1, 1)]
void Particles(uint3 id : SV_DispatchThreadID)
{
	uint w, h;
	NewFrame.GetDimensions(w, h);
	for(uint i = 0; i < h; i++)
	{
		int2 coords = int2(id.x, i);
		int2 coordsAbove = coords + eee.yx;
		NewFrame[coords] = FrameBefore[coords];
		float4 col = FrameBefore[coordsAbove];
		if (IS_EMPTY(FrameBefore[coords]) || (IS_EQUAL(FrameBefore[coords], LAVA) && IS_MINED(col)))
		{
			if (IS_MOVABLE(col))
			{
				int2 coordsLeft = coordsAbove + eee.xy;
				int2 coordsRight = coordsAbove + eee.zy;
				if (IS_EQUAL(NewFrame[coordsLeft], BELT_UP) || IS_EQUAL(NewFrame[coordsRight], BELT_UP)) continue;
				NewFrame[coords] = FrameBefore[coordsAbove];
				FrameBefore[coordsAbove] = 0;
			}
		}
	}
}

#pragma kernel RightToLeft
[numthreads(1, 256, 1)]
void RightToLeft(uint3 id : SV_DispatchThreadID)
{
	uint w, h;
	NewFrame.GetDimensions(w, h);
	for(int i = (int)w - 1; i > 0; i--)
	{
		int2 coords = int2(i, id.y);
		int2 coordsAbove = coords + eee.yx;
		int2 coordsAboveLeft = coords + eee.zx;
		if (IS_EQUAL(NewFrame[coords], BELT_LEFT))
		{
			if (IS_EMPTY(NewFrame[coordsAboveLeft]) && IS_MOVABLE(NewFrame[coordsAbove]))
			{
				NewFrame[coordsAboveLeft] = NewFrame[coordsAbove];
				NewFrame[coordsAbove] = 0;
				i--;
			}
		}
		else
		{
			int2 coordsLeft = coords + eee.xy;
			int2 coordsRight = coords + eee.zy;
			if (IS_EQUAL(NewFrame[coordsLeft], BELT_UP) || IS_EQUAL(NewFrame[coordsRight], BELT_UP)) continue;
			if (IS_MOVABLE(NewFrame[coords]) && coords.y + eee.z >=0)
			{
				if (IS_EMPTY(NewFrame[coords + eee.xz]))
				{
					NewFrame[coords + eee.xz] = NewFrame[coords];
					NewFrame[coords] = 0;
				}
				else if (IS_LIQUID(NewFrame[coords]) && (IS_EMPTY(NewFrame[coords+eee.xy]) || IS_EQUAL(NewFrame[coords + eee.xy], TORCH)) && (uint)(coords.x + eee.x) < w && rand(coords, 0))
				{
					NewFrame[coords+eee.xy] = NewFrame[coords];
					NewFrame[coords] = 0;
				}
				else if (IS_LIQUID(NewFrame[coords + eee.xz]) && rand(coords + eee.xz, 1))
				{
					float4 temp = NewFrame[coords + eee.xz];
					NewFrame[coords + eee.xz] = NewFrame[coords];
					NewFrame[coords] = temp;
				}
				else if (IS_EQUAL(NewFrame[coords], LAVA) && IS_EQUAL(NewFrame[coords + eee.xy], WATER))
				{
					NewFrame[coords] = ROCK1;
					NewFrame[coords + eee.xy] = 0;
				}
			}
		}
	}
}

#pragma kernel LeftToRight
[numthreads(1, 256, 1)]
void LeftToRight(uint3 id : SV_DispatchThreadID)
{
	uint w, h;
	NewFrame.GetDimensions(w, h);
	int wLess = (int)w - 1;
	for(int i = 0; i < wLess; i++)
	{
		int2 coords = int2(i, id.y);
		int2 coordsAbove = coords + eee.yx;
		int2 coordsAboveRight = coords + eee.xx;
		if (IS_EQUAL(NewFrame[coords], BELT_RIGHT))
		{
			if (IS_EMPTY(NewFrame[coordsAboveRight]) && IS_MOVABLE(NewFrame[coordsAbove]))
			{
				NewFrame[coordsAboveRight] = NewFrame[coordsAbove];
				NewFrame[coordsAbove] = 0;
				i++;
			}
		}
		else
		{
			int2 coordsLeft = coords + eee.xy;
			int2 coordsRight = coords + eee.zy;
			if (IS_EQUAL(NewFrame[coordsLeft], BELT_UP) || IS_EQUAL(NewFrame[coordsRight], BELT_UP)) continue;
			if (IS_MOVABLE(NewFrame[coords]) && coords.y + eee.z >= 0)
			{
				if (IS_EMPTY(NewFrame[coords + eee.zz]))
				{
					NewFrame[coords + eee.zz] = NewFrame[coords];
					NewFrame[coords] = 0;
				}
				else if (IS_LIQUID(NewFrame[coords]) && (IS_EMPTY(NewFrame[coords + eee.zy]) || IS_EQUAL(NewFrame[coords + eee.zy], TORCH)) && coords.x + eee.z >= 0 && rand(coords, 0))
				{
					NewFrame[coords + eee.zy] = NewFrame[coords];
					NewFrame[coords] = 0;
				}
				else if (IS_LIQUID(NewFrame[coords + eee.zz]) && rand(coords + eee.zz, 1))
				{
					float4 temp = NewFrame[coords + eee.zz];
					NewFrame[coords + eee.zz] = NewFrame[coords];
					NewFrame[coords] = temp;
				}
				else if (IS_EQUAL(NewFrame[coords], LAVA) && IS_EQUAL(NewFrame[coords + eee.zy], WATER))
				{
					NewFrame[coords] = ROCK1;
					NewFrame[coords + eee.zy] = 0;
				}
			}
		}
	}
}

#pragma kernel DownToUp
[numthreads(256, 1, 1)]
void DownToUp(uint3 id : SV_DispatchThreadID)
{
	uint w, h;
	NewFrame.GetDimensions(w, h);
	for(uint i = 0; i < h; i++)
	{
		int2 coords = int2(id.x, i);
		int2 coordsAbove = coords + eee.yx;
		int2 coordsLeft = coords + eee.xy;
		int2 coordsRight = coords + eee.zy;
		int2 coordsTwoAbove = coordsAbove + eee.yx;
		if (IS_EQUAL(NewFrame[coordsLeft], BELT_UP) || IS_EQUAL(NewFrame[coordsRight], BELT_UP))
		{
			if (IS_MOVABLE(NewFrame[coords]))
			{
				if (IS_BELT(NewFrame[coordsAbove]) && IS_EMPTY(NewFrame[coordsTwoAbove]))
				{
					NewFrame[coordsTwoAbove] = NewFrame[coords];
					NewFrame[coords] = 0;
				}
				else if (IS_EMPTY(NewFrame[coordsAbove]))
				{
					NewFrame[coordsAbove] = NewFrame[coords];
					NewFrame[coords] = 0;
					i++;
				}
			}
		}
		else if (IS_EQUAL(NewFrame[coordsAbove], LAVA) && IS_MINED(NewFrame[coords]))
		{
			NewFrame[coords] = LAVA;
			NewFrame[coordsAbove] = 0;
		}
		else if (IS_MINED(NewFrame[coordsAbove]) && IS_LIQUID(NewFrame[coords]))
		{
			float4 temp = NewFrame[coordsAbove];
			NewFrame[coordsAbove] = NewFrame[coords];
			NewFrame[coords] = temp;
		}
		else if (IS_EQUAL(NewFrame[coords], LAVA) && IS_EQUAL(NewFrame[coordsAbove], WATER))
		{
			NewFrame[coords] = ROCK1;
			NewFrame[coordsAbove] = 0;
		}
	}
}

#pragma kernel PlaceThings

void MakeLeaves(int2 leavesStart)
{
	for (int x = -1; x < 2; x++)
	{
		for (int y = -1; y < 2; y++)
		{
			int2 coords = leavesStart + int2(x, y);
			if (IS_EMPTY(NewFrame[coords]))
			{
				NewFrame[coords] = TREE_LEAVES;
			}
		}
	}
}

void MakeTreeBranch(int2 branchStart, bool direction)
{
	int3 dirVector = int3(1, 0, direction ? 1 : -1);
	branchStart += dirVector.zy;
	NewFrame[branchStart] = TREE_TRUNK;
	MakeLeaves(branchStart);
	branchStart += dirVector.zy;
	NewFrame[branchStart] = TREE_TRUNK;
	MakeLeaves(branchStart);
	branchStart += dirVector.zx;
	NewFrame[branchStart] = TREE_TRUNK;
	MakeLeaves(branchStart);
	branchStart += dirVector.zx;
	NewFrame[branchStart] = TREE_TRUNK;
	MakeLeaves(branchStart);
}

[numthreads(1, 1, 1)]
void PlaceThings(uint3 id : SV_DispatchThreadID)
{
	uint mapW, mapH;
	NewFrame.GetDimensions(mapW, mapH);
	
	for (int treeIndex = 0; treeIndex < MAPGEN_SURFACE_TREE_COUNT; treeIndex++)
	{
		int treeX = (int)((seedNoise(int2(treeIndex + 0.5, MAPGEN_SURFACE_TREE_COUNT + 0.5)) + 1) * 0.5 * mapW);
		if (treeX + 15 > SHOP_PLACEMENT.x && treeX - 10 < SHOP_PLACEMENT.x) continue;
		int treeStartY = 1023;
		float4 spaceCol = NewFrame[int2(treeX, treeStartY - 1)];
		while (IS_EMPTY(spaceCol) || IS_EQUAL(spaceCol, TREE_TRUNK) || IS_EQUAL(spaceCol, TREE_LEAVES))
		{
			treeStartY--;
			spaceCol = NewFrame[int2(treeX, treeStartY - 1)];
		}
		int treeY = 0;
		int treeHeight = 10;
		for (; treeY < treeHeight; treeY++)
		{
			int2 branchPos = int2(treeX, treeY + treeStartY);
			NewFrame[branchPos] = TREE_TRUNK;
			if (treeY > 5 && rand(branchPos) && rand(branchPos, 1))
			{
				MakeTreeBranch(branchPos, rand(branchPos, 3));
				treeHeight += 1;
			}
		}
		for (int i = 0; i < 5; i++)
		{
			int2 noiseMove = int2((int)round(seedNoise(int2(treeX + 0.5, treeY + 1.5)) * 2), (int)round(-abs(seedNoise(int2(treeX + 0.5, treeY + 1.5)) * 2)));
			bool rnd = rand(int2(treeX + 0.5, treeY + 1.5), i + 3);
			if (rnd)
			{
				noiseMove.x = -abs(noiseMove.x);
			}
			else
			{
				noiseMove.x = abs(noiseMove.x);
			}
			MakeTreeBranch(int2(treeX, treeY + treeStartY) + noiseMove, rnd);
		}
	}
	
	for (int idx = 0; idx < 3; idx++)
	{
		for (int idy = 0; idy < 5; idy++)
		{
			float number = idx * 5 + idy;
			float4 x = float4(number / 15.0, 0.1, 0.1, 1.0);
			NewFrame[int2(idx, idy) + SHOP_PLACEMENT] = x;
		}
	}
	
	for (int i = -9; i < 3; i++)
	{
		int2 coord = SHOP_PLACEMENT + eee.yz + int2(i, 0);
		NewFrame[coord] = BEDROCK;
		while(IS_EMPTY(NewFrame[coord]))
		{
			NewFrame[coord] = BEDROCK;
			coord += eee.yz;
		}
	}
	
	int2 coord = SHOP_PLACEMENT + eee.yz + int2(-10, 0);
	while(IS_EMPTY(NewFrame[coord]))
	{
		NewFrame[coord] = LADDER;
		coord += eee.yz;
	}
	coord = SHOP_PLACEMENT + eee.yz + int2(3, 0);
	while(IS_EMPTY(NewFrame[coord]))
	{
		NewFrame[coord] = LADDER;
		coord += eee.yz;
	}
}

#pragma kernel Treenemy
[numthreads(16, 16, 1)]
void Treenemy(uint3 id : SV_DispatchThreadID)
{
	int2 coords = id.xy;
	int2 coordsAbove = id.xy + eee.yx;
	int2 coordsBelow = id.xy + eee.yz;
	int2 coordsLeft = id.xy + eee.zy;
	int2 coordsRight = id.xy + eee.xy;
	float4 tile = NewFrame[coords];
	float4 tileAbove = NewFrame[coordsAbove];
	float4 tileBelow = NewFrame[coordsBelow];
	float4 tileLeft = NewFrame[coordsLeft];
	float4 tileRight = NewFrame[coordsRight];
	if (IS_TREENEMY_BRANCH(tile))
	{
		if (IS_LIQUID(tileAbove))
		{
			NewFrame[coordsAbove] = TREENEMY_BRANCH_ASLEEP;
		}
		if (IS_LIQUID(tileBelow))
		{
			NewFrame[coordsBelow] = TREENEMY_BRANCH_ASLEEP;
		}
		if (IS_LIQUID(tileLeft))
		{
			NewFrame[coordsLeft] = TREENEMY_BRANCH_ASLEEP;
		}
		if (IS_LIQUID(tileRight))
		{
			NewFrame[coordsRight] = TREENEMY_BRANCH_ASLEEP;
		}
		if (tile.y > 0.15)
		{
			tile.y -= 0.1;
			NewFrame[coords] = tile;
		}
		if (tile.y < 0.15 && (
			IS_TREENEMY_TRIGGER(tileAbove) ||
			IS_TREENEMY_TRIGGER(tileBelow) ||
			IS_TREENEMY_TRIGGER(tileLeft) ||
			IS_TREENEMY_TRIGGER(tileRight)))
		{
			tile.y = 1.0;
			NewFrame[coords] = tile;
			if (snoise(float3(id.xy * 0.05, Time)) > 0.5)
			{
				if (!IS_EMPTY(tileAbove) && !IS_TREENEMY_CORE(tileAbove) &&
					(
						!IS_TREENEMY_BRANCH(NewFrame[coordsAbove+eee.xy]) &&
						!IS_TREENEMY_BRANCH(NewFrame[coordsAbove+eee.zy]) &&
						!IS_TREENEMY_BRANCH(NewFrame[coordsAbove+eee.yx])
					))
				{
					NewFrame[coordsAbove] = TREENEMY_BRANCH_ASLEEP;
				}
				if (!IS_EMPTY(tileBelow) && !IS_TREENEMY_CORE(tileBelow) &&
					(
						!IS_TREENEMY_BRANCH(NewFrame[coordsBelow+eee.xy]) &&
						!IS_TREENEMY_BRANCH(NewFrame[coordsBelow+eee.zy]) &&
						!IS_TREENEMY_BRANCH(NewFrame[coordsBelow+eee.yz])
					))
				{
					NewFrame[coordsBelow] = TREENEMY_BRANCH_ASLEEP;
				}
				if (!IS_EMPTY(tileLeft) && !IS_TREENEMY_CORE(tileLeft) &&
					(
						!IS_TREENEMY_BRANCH(NewFrame[coordsLeft+eee.zy]) &&
						!IS_TREENEMY_BRANCH(NewFrame[coordsLeft+eee.yz]) &&
						!IS_TREENEMY_BRANCH(NewFrame[coordsLeft+eee.yx])
					))
				{
					NewFrame[coordsLeft] = TREENEMY_BRANCH_ASLEEP;
				}
				if (!IS_EMPTY(tileRight) && !IS_TREENEMY_CORE(tileRight) &&
					(
						!IS_TREENEMY_BRANCH(NewFrame[coordsRight+eee.xy]) &&
						!IS_TREENEMY_BRANCH(NewFrame[coordsRight+eee.yz]) &&
						!IS_TREENEMY_BRANCH(NewFrame[coordsRight+eee.yx])
					))
				{
					NewFrame[coordsRight] = TREENEMY_BRANCH_ASLEEP;
				}
			}
			
		}
	}
	else if (IS_TREENEMY_CORE(tile))
	{
		float timeToSignal = tile.y - 0.1;
		if (timeToSignal >= -0.05)
		{
			if (timeToSignal < 0.05)
			{
				tile.y = 1.0;
				NewFrame[coords] = tile;
			}
			else
			{
				tile.y -= 0.1;
				NewFrame[coords] = tile;
			}
		}
		else if (
			IS_TREENEMY_TRIGGER(tileAbove) ||
			IS_TREENEMY_TRIGGER(tileBelow) ||
			IS_TREENEMY_TRIGGER(tileLeft) ||
			IS_TREENEMY_TRIGGER(tileRight))
		{
			tile.y = 0.1;
			NewFrame[coords] = tile;
		}
	}
}

#pragma kernel TreenemySpawn
[numthreads(MAPGEN_TREENEMY_COUNT, 1, 1)]
void TreenemySpawn(uint3 id : SV_DispatchThreadID)
{
	uint w, h;
	NewFrame.GetDimensions(w, h);
	int genSeed = seed * (id.x + 1);
	int2 spawnPoint = int2((snoise(float2(genSeed + 0.5, 0.5)) + 1) * w / 2, (snoise(float2(0.5, genSeed + 0.5)) + 1) * h / 2);
	NewFrame[spawnPoint] = TREENEMY_CORE_ASLEEP;
	for (uint branchID = 0; branchID < MAPGEN_TREENEMY_BRANCH_COUNT; branchID++)
	{
		int2 branchCoords = spawnPoint;
		int2 lastBranchDir = eee.yy;
		for (uint branchLen = 0; branchLen < MAPGEN_TREENEMY_BRANCH_LENGTH; branchLen++)
		{
			float branchNoise = trunc((snoise(float2(genSeed + branchID * 21 + trunc(branchLen / 2) * 31 + 0.5, 0.5)) + 1) * 2);
			int2 branchDir = eee.yz;
			switch(branchNoise)
			{
				case 0:
					branchDir = eee.xy;
					break;
				case 1:
					branchDir = eee.yx;
					break;
				case 2:
					branchDir = eee.zy;
					break;
			}
			if (IS_EQUAL(lastBranchDir + branchDir, eee.yy))
			{
				branchDir = lastBranchDir;
			}
			branchCoords += branchDir;
			lastBranchDir = branchDir;
			if (!IS_TREENEMY_CORE(NewFrame[branchCoords]))
			{
				NewFrame[branchCoords] = TREENEMY_BRANCH_ASLEEP;
			}
		}
	}
}